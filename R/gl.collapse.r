#' Collapse a distance matrix by amalgamating populations with pairwise fixed difference count less that an threshold
#'
#' This script takes a the file generated by gl.fixed.diff and generates a population recode
#' table to amalgamate populations with distance less than or equal to a specified threshold
#' The distance matrix is generated by gl.fixed.diff()
#' 
#' The script then applies the recode to the genlight object and recalculates the distance and associated matricies.
#'
#' @param fd -- name of the list of matricies produced by gl.fixed.diff() [required]
#' @param recode.table -- name of the new recode.table to receive the new population reassignments 
#' arising from the amalgamation of populations [tmp.csv]
#' @param outpath -- path where to save the output file [default tempdir(), mandated by CRAN]. Use outpath=getwd() or outpath="." when calling this function to direct output files to your working directory.
#' @param tloc -- threshold defining a fixed difference (e.g. 0.05 implies 95:5 vs 5:95 is fixed) [0]
#' @param test -- should a test be performed, default is [FALSE]
#' @param delta -- needs to be described
#' @param reps -- number of repeats - needs to be described
#' @param tpop -- threshold number of fixed differences above which populatons will not be amalgamated [0]
#' @param plot -- if TRUE, plot a PCoA with the new groupings [FALSE]
#' @param pb -- if TRUE, show a progress bar on time consuming loops [FALSE]
#' @param verbose -- verbosity: 0, silent or fatal errors; 1, begin and end; 2, progress log ; 3, progress and results summary; 5, full report [default 2 or as specified using gl.set.verbosity]
#' @return A list containing the gl object x and the following square matricies
#'         [[1]] $gl -- the new genlight object with populations collapsed;
#'         [[2]] $fd -- raw fixed differences;
#'         [[3]] $pcfd -- percent fixed differences;
#'         [[4]] $nobs -- mean no. of individuals used in each comparison;
#'         [[5]] $nloc -- total number of loci used in each comparison;
#'         [[6]] $expobs -- if test=TRUE, the expected count of false positives for each comparison [by simulation];
#'         [[7]] $prob -- if test=TRUE, the significance of the count of fixed differences [by simulation])
#' @importFrom methods show       
#' @export
#' @author Arthur Georges (Post to \url{https://groups.google.com/d/forum/dartr})
#' @examples
#' \donttest{
#' fd <- gl.fixed.diff(testset.gl, tloc=0.05)
#' gl <- gl.collapse(fd, recode.table="testset_recode.csv",tpop=1)
#' }

gl.collapse <- function(fd, 
                        recode.table="tmp.csv",
                        outpath=tempdir(),
                        tpop=0, 
                        tloc=0, 
                        test=FALSE,
                        delta = 0.02,
                        reps = 1000,
                        plot=FALSE,
                        pb=FALSE,
                        verbose=NULL) {
  
# TRAP COMMAND, SET VERSION
  
  funname <- match.call()[[1]]
  build <- "Jacob"
  
# SET VERBOSITY
  
  if (is.null(verbose)){ 
      verbose <- 2
  } 
  
  if (verbose < 0 | verbose > 5){
    cat(paste("  Warning: Parameter 'verbose' must be an integer between 0 [silent] and 5 [full report], set to 2\n"))
    verbose <- 2
  }
  
# FLAG SCRIPT START
  
  if (verbose >= 1){
    if(verbose==5){
      cat("Starting",funname,"[ Build =",build,"]\n")
    } else {
      cat("Starting",funname,"\n")
    }
  }
  
# STANDARD ERROR CHECKING
  
  if (!("fd" %in% names(fd)) ||
      !("pcfd" %in% names(fd)) ||
      !("nobs" %in% names(fd)) ||
      !("nloc" %in% names(fd)) ||
      !("pval" %in% names(fd)) ||
      !("expobs" %in% names(fd))) {
    stop("Fatal Error: fd must be a list produced by gl.collapse\n")
  }
  
# FUNCTION SPECIFIC ERROR CHECKING
  
  if (tloc > 0.5 || tloc < 0 ) {
    stop("Fatal Error: Parameter tloc should be positive in the range 0 to 0.5\n")
  } 
  
  if (tpop < 0 ) {
    stop("Fatal Error: Parameter tpop should be a positive integer\n")
  }  
  
# DO THE JOB
  
  if ( verbose >= 2){
    if (tloc > 0) {cat("  Comparing populations for fixed differences with tolerance",tloc,"\n")}
    if (tloc == 0) {cat("  Comparing populations for absolute fixed differences\n")}
    if (tpop > 0) {cat("  Amalgamating populations with fixed differences <= ",tpop,"\n")}
    if (tpop == 0) {cat("  Amalgamating populations with zero fixed differences\n")}
  }

# Store the number of populations in the matrix
  npops <- dim(fd$fd)[1]
  
# Extract the column names
  pops <- variable.names(fd$fd)
  
# Initialize a list to hold the populations that differ by <= tpop
  zero.list <- list()

  # For each pair of populations
  for(i in 1:npops){
    zero.list[[i]] <- c(rownames(fd$fd)[i])
    for (j in 1:npops) {
      if (fd$fd[i,j] <= tpop) {
        zero.list[[i]] <- c(zero.list[[i]],rownames(fd$fd)[i],rownames(fd$fd)[j])
        zero.list[[i]] <- unique(zero.list[[i]])
      }
    }
    zero.list[[i]] <- sort(zero.list[[i]])
  }
  
# Pull out the unique aggregations  
  zero.list <- unique(zero.list)
  
# Amalgamate populations
  if (length(zero.list) >= 2) {
    for (i in 1:(length(zero.list)-1)) {
      for (j in 2:length(zero.list)) {
        if (length(intersect(zero.list[[i]],zero.list[[j]])) > 0 ) {
          zero.list[[i]] <- union(zero.list[[i]],zero.list[[j]])
          zero.list[[j]] <- union(zero.list[[i]],zero.list[[j]])
        }
      }
    }
    for (i in 1:length(zero.list)) {
      zero.list <- unique(zero.list)
    }
  }  

# Print out the results of the aggregations 
  if(verbose >= 3) {
    cat("\nInitial Populations\n",pops,"\n")
    cat("\nNew population groups\n")
  }
  
  for (i in 1:length(zero.list)) {
    # Create a group label
      if (length(zero.list[[i]])==1) {
        replacement <- zero.list[[i]][1]
      } else {
        replacement <- paste0(zero.list[[i]][1],"+")
        if(verbose >= 3) {
          cat(paste0("Group:",replacement,"\n"))
          print(as.character(zero.list[[i]]))
          cat("\n")
        }
      }
    # Create a dataframe with the pop names and their new group names  
      if (i==1) {
        df <- rbind(data.frame(zero.list[[i]],replacement, stringsAsFactors = FALSE))
      } else {
        df <- rbind(df,data.frame(zero.list[[i]],replacement, stringsAsFactors = FALSE))
      }
  }

# Create a recode table corresponding to the aggregations
    outfilespec <- file.path(outpath, recode.table)
    write.table(df, file=outfilespec, sep=",", row.names=FALSE, col.names=FALSE)
  
# Recode the data file (genlight object)
    x2 <- gl.recode.pop(fd$gl, pop.recode=outfilespec, verbose=0)
    fd2 <- gl.fixed.diff(x2,tloc=tloc,test=test,delta=delta,reps=reps,pb=pb,verbose=2)

  if(setequal(nPop(x2),nPop(fd$gl))) { 
    if (verbose >= 2) {
      cat(paste("\nNo further amalgamation of populations at fd <=", tpop,"\n"))
      cat("  Recursive analysis complete\n\n")
    }
    # Plot the results  
    if (plot){
      pcoa <- gl.pcoa(x2,verbose=verbose)
      tmp <- gl.pcoa.plot(pcoa,x2)
      show(tmp)
    }  
    l <- list(gl=fd$gl,fd=fd2$fd,pcfd=fd2$pcfd,nobs=fd2$nobs,nloc=fd2$nloc,expobs=fd2$expobs,pval=fd2$pval)
  } else {
    # Display the fd matrix
    if (verbose >= 4) {
      cat("\n\nRaw Fixed Difference Matrix\n")
      print(fd2$fd)
      cat("\n")
    }
    if (verbose >= 3) {
      cat("Sample sizes")
      print(table(pop(x2)))
      cat("\n")
    }
    # Plot the results  
    if (plot){
      pcoa <- gl.pcoa(x2,verbose=verbose)
      tmp <- gl.pcoa.plot(pcoa,x2)
      show(tmp)
    }  
    
    l <- list(gl=x2,fd=fd2$fd,pcfd=fd2$pcfd,nobs=fd2$nobs,nloc=fd2$nloc,expobs=fd2$expobs,pval=fd2$pval)
  }

  # Explanatory bumpf
    if (verbose >= 4) {
      if(pb){cat("\n")}
      cat("Returning a list containing the new genlight object and square matricies, as follows:\n",
          "         [[1]] $gl -- input genlight object;\n",
          "         [[2]] $fd -- raw fixed differences;\n",
          "         [[3]] $pcfd -- percent fixed differences;\n",
          "         [[4]] $nobs -- mean no. of individuals used in each comparison;\n",
          "         [[5]] $nloc -- total number of loci used in each comparison;\n",
          "         [[6]] $expobs -- if test=TRUE, the expected count of false positives for each comparison [by simulation]\n",
          "         [[7]] $prob -- if test=TRUE, the significance of the count of fixed differences [by simulation]\n")
    }
    
# FLAG SCRIPT END
  
  if (verbose > 0) {
    cat("Completed:",funname,"\n")
  }
  
  return(l)
}
